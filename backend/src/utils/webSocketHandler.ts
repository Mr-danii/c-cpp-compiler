/**
 * Socket.IO Handler
 * Centralized utilities for Socket.IO communication
 */
import { Server as SocketIOServer, Socket } from "socket.io";
import { EventEmitter } from "events";
import http from "http";

// Define Socket interface with session data
export interface SessionSocket extends Socket {
  sessionId: string;
}

// Events emitter for cross-component communication
export const socketEvents = new EventEmitter();

// Event types for strong typing
export enum SocketEvents {
  // Connection lifecycle events
  CONNECT = "connect",
  DISCONNECT = "disconnect",

  // Compilation events
  COMPILE = "compile",
  COMPILING = "compiling",
  COMPILE_SUCCESS = "compile_success",
  COMPILE_ERROR = "compile_error",

  // Execution events
  OUTPUT = "output",
  INPUT = "input",
  EXIT = "exit",
  RESIZE = "resize",

  // Session management
  SESSION_CREATED = "session_created",
  CLEANUP = "cleanup",
  CLEANUP_COMPLETE = "cleanup_complete",

  // Error handling
  ERROR = "error",
}

/**
 * WebSocket Manager Class
 * Central handler for all Socket.IO operations
 */
export class WebSocketManager {
  private io: SocketIOServer | null = null;
  
  /**
   * Initialize Socket.IO server
   * @param {http.Server} server - HTTP server to attach Socket.IO
   * @returns {SocketIOServer} Configured Socket.IO server
   */
  initialize(server: http.Server): SocketIOServer {
    this.io = new SocketIOServer(server, {
      cors: {
        origin: "*",
        methods: ["GET", "POST"],
      },
      transports: ["websocket", "polling"],
    });

    // Set up connection handler
    this.io.on(SocketEvents.CONNECT, (socket: Socket) => {
      // Initialize socket with session ID (UUID will be generated by the message handler)
      const sessionSocket = socket as SessionSocket;

      // Handle disconnect
      socket.on(SocketEvents.DISCONNECT, () => {
        socketEvents.emit("socket-disconnect", {
          socketId: socket.id,
          sessionId: sessionSocket.sessionId,
        });
      });

      // Emit internal event about new connection
      socketEvents.emit("socket-connect", {
        socketId: socket.id,
        socket: sessionSocket,
      });
    });

    return this.io;
  }

  /**
   * Send a message to a specific client
   * @param {Socket} socket - Socket.IO socket
   * @param {string} event - Event name
   * @param {any} data - Data to send
   */
  emitToClient(socket: Socket, event: string, data: any): void {
    if (socket && socket.connected) {
      socket.emit(event, data);
    }
  }
  
  /**
   * Broadcast a message to all connected clients
   * @param {string} event - Event name
   * @param {any} data - Data to send
   * @param {string} [room] - Optional room to broadcast to
   */
  broadcast(event: string, data: any, room?: string): void {
    if (!this.io) return;
    
    if (room) {
      this.io.to(room).emit(event, data);
    } else {
      this.io.emit(event, data);
    }
  }
  
  /**
   * Get the Socket.IO server instance
   * @returns {SocketIOServer | null} Socket.IO server instance
   */
  getIO(): SocketIOServer | null {
    return this.io;
  }
}

// Create singleton instance
export const webSocketManager = new WebSocketManager();

// Legacy compatibility functions
/**
 * Create and configure a Socket.IO server
 * @param {http.Server} server - HTTP server to attach Socket.IO
 * @returns {SocketIOServer} Configured Socket.IO server
 */
export const createSocketServer = (server: http.Server): SocketIOServer => {
  return webSocketManager.initialize(server);
};

/**
 * Send a message to a client
 * @param {Socket} socket - Socket.IO socket
 * @param {string} event - Event name
 * @param {any} data - Data to send
 */
export const emitToClient = (
  socket: Socket,
  event: string,
  data: any
): void => {
  webSocketManager.emitToClient(socket, event, data);
};
